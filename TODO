
Hey, it's a solo project! I get to use this TODO format again!

BEFORE FIRST VERSION

  o Make both implementations work n*64-bytes at a time, with
    persistent state. Use that as a backend for the RNG.
  o Add a frontend that wraps the 64-bytes backend into a
    proper bytewise RNG.
  o Seed from the OS.  Facility to seed from extra stuff if
    you're paranoid.
  o frontend that returns an unsigned.

  o Thread-safety: lock the thing.
    o pthreads
  o Handle fork() safely.
    o getpid() on each call?
  o Code to clear the stack.
  o A mixing/stirring feature

  o frontend that returns an unsigned within a range.

  o Rename.

  o Build/benchmark with -fPIC

  o Static state functions.

  o Well-considered set of what APIs to export
    o Initial state-based thing.
    o Initial static thing

  . Working headers
  o Build with more warnings
  o Pluggable backends.

  . Add a benchmarking/timing feature
    - do it right.

  . Test with dieharder, to see if I screwed up.
  - Document APIs.
  - Finish the readme
  o Tests for chacha12
  - 100% test coverage.
  - Resolve every XXXX
  - comment it

  o Strip out ability to use chacha as stream cipher: it would be bad to do
    so given how I'm going to tweak it.

  - Switch from initialized-check to magic-number check?

  o Remove the idx_step logic; it's an accident waiting to happen

BEFORE FINAL VERSION

  - Waste fewer bytes when stirring.

  - Detect CPU features at runtime.
    - In particular, detecting SSE3/SSE2 could be a bit of a win.

  - Separate threaded/nonthreaded libraries.

  - Handle fork even better
    - mutex/state in a shared mmap?
    - pthread_atfork?
    - Ignore when we have a state object

  - Handle thread-safety even better
    - ability to disable locking.
    - Per-pthread?
    - pthread_spin?
    - When about to generate a ton of stuff, increment the counter *then*
      drop the lock!

  - Do something about L1 cache pressure.

  - Use AESNI instead of chacha when it's available?
    o Port implementation (see branch 'aesni')
    - Test implementation
    - Use it when appropriate.

  - Windows port
    - Windows threads
    - No need for fork detection.

  - Other entropy sources besides /dev/urandom
    - User-specified device
    - Syscall/ioctl
    - That windows thing.
    - User promises to seed (dangerous)

  - Drop endianness conversion; not needed for PRNG usage

  - Port to MSVC

  - Test on altivec, fix whatever I broke there.

  o Drop support for 64-bit counters: 256GB is enough for anyone.

  - avoid redundant initialization checks.


