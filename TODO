Hey, it's a solo project! I get to use this TODO format again!

- Not done.
. Partially done.
o Completed.
X Abandoned.

BEFORE EVERY RELEASE
  - 100% test coverage.
    (Well, there are 1-5 non-covered lines, but that's okay.)

  - Uncrustify.

  - Valgrind.

  - Dieharder

  - Build and test on:
    - Windows, Windows64 (mingw)
    - ARM
    - FreeBSD
    - OSX
    - Fedora

BEFORE FIRST ALPHA VERSION

  o First-class coverage support in autotools files.

  - Triple-check that ssse3 code is getting built and run.

  - Rename stir

  - Refactor locking.
    - Don't spin inappropriately.
      - In particular, don't spin over any access to the entropy source!

  - TESTING
    . Add a benchmarking/timing feature
      - do it right. Use a CPU timer, not gettimeofday.
    . Test with dieharder, to see if I screwed up.
      . Better dumpbytes output.  Use all backends, different sizes,
        multiple threads...
        o Implement better dump_bytes
          o Make it explain itself.
        . Test it.
    . Specify and clone in a more spec-y language; make sure it calls itself
      properly.
      o Clone it in haskell
      o Make the haskell clone work
      o Make the haskell clone work for output_len != 1024
      - Double-check the spec against the haskell clone

  X Simplify large/small request issues?

  - Make sure that the reinitialization logic is threadsafe.

BEFORE VERSION 1:

  o Detect CPU features at runtime.
    o In particular, detecting SSSE3/SSE2 could be a bit of a win.
    - Detect ARM neon
    - Detect altivec simd

  - Separate threaded/nonthreaded libraries.

  o Windows port
    o Windows threads
    o No need for fork detection.
    - Good build process
    - Coverage on Windows

  . Other entropy sources besides /dev/urandom
    - User-specified /dev/*random
      o Implement
      o Make it user-specified
      o Allow an fd.
      o Make sure it's a device!
      - Make sure it has correct major/minor?
      - Make sure major/minor doesn't change on us.
    - Syscall/ioctl/arc4random??
    o Notion of redundant sources so we try syscall only if read fails.
    o rdrand instruction.
    o That windows thing.
    - User promises to seed (dangerous)
    - Ability to say "Still use X, but don't consider it strong."
    o Better ways to combine data.
    o egd, prngd
    o Good API.

  o Read entropy sources until all the bytes are there.

  - Possibly, add a "stir" step after seeding so that we are never
    generating PRNG data directly from a key not produced by the PRF.

  - Test on altivec, fix whatever I broke there.

  - Rudimentary prediction resistance:
    - opportunistic, if you have a fast entropy source.
    - timed?
    - every N bytes?

  - Function to return a bitmask of any bogus options that the library was
    built with.

  - pthread_atfork for fork handling

  - mlock.

SOMEDAY:
  - avoid redundant initialization checks.

  . Option to avoid leaving stuff on the stack.

  - Ability to make a tiny tiny runtime for embedded applications.

  - Port to MSVC

  - Port to ancient operating systems

  - Port to weird chips.

  - Handle fork even better. Ideas:
    - mutex/state in a shared mmap?
    . pthread_atfork?
      (Hm, it appears that sensible libcs make getpid() pretty fast, so this
       isn't a win the way I did it at first.)
    - Ignore when we have a state object??

  - Handle thread-safety even better
    o ability to disable locking.
    - Per-pthread?
    - pthread_spin?
    - When about to generate a ton of stuff, increment the counter *then*
      drop the lock!
  - Do something about L1 cache pressure.


REJECTED:
  X Use AESNI instead of chacha when it's available?
    o Port implementation (see branch 'aesni')
    o Benchmark implementation.
      (NOT FASTER THAN CHACHA.)
    X Test implementation
    X Use it when appropriate.

  X Make rand_bytes() better handle the case where, after alignment, n is
    less than output_len?

  X Expose OSRNG functions.

