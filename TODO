
Hey, it's a solo project! I get to use this TODO format again!

BEFORE FIRST VERSION

  o Make both implementations work n*64-bytes at a time, with
    persistent state. Use that as a backend for the RNG.
  o Add a frontend that wraps the 64-bytes backend into a
    proper bytewise RNG.
  o Seed from the OS.  Facility to seed from extra stuff if
    you're paranoid.
  o frontend that returns an unsigned.

  o Thread-safety: lock the thing.
    o pthreads
  o Handle fork() safely.
    o getpid() on each call?
  o Code to clear the stack.
  o A mixing/stirring feature

  o frontend that returns an unsigned within a range.

  o Rename.

  o Build/benchmark with -fPIC

  o Static state functions.

  o Well-considered set of what APIs to export
    o Initial state-based thing.
    o Initial static thing

  o Working headers
  o Build with more warnings
  o Pluggable backends.
  o Tests for chacha12

  o Resolve every XXXX

  o Strip out ability to use chacha as stream cipher: it would be bad to do
    so given how I'm going to tweak it.

  o Switch from initialized-check to magic-number check?

  o Remove the idx_step logic; it's an accident waiting to happen

  - TESTING
    . Add a benchmarking/timing feature
      - do it right.
    . Test with dieharder, to see if I screwed up.
      . Better dumpbytes output.  Use all backends, different sizes,
        multiple threads...
        . Implement better dump_bytes
          - Make it explain itself.
        . Test it.
    . Specify and clone in a more spec-y language; make sure it calls itself
      properly.
    - Make a test_deep.
    o 100% test coverage.

  o DOCUMENTATION
    o Document APIs.
    o Finish the readme
    o comment all the code

  - CONSISTENCY
    - Uncrustify

BEFORE FINAL VERSION

  . Option to avoid leaving stuff on the stack.

  - Ability to make a tiny tiny runtime for embedded applications.

  - Make sure that the reinitialization logic is threadsafe.

  - Separate the function for reseeding and reinitializing.

  o Waste fewer bytes when stirring.

  - Detect CPU features at runtime.
    - In particular, detecting SSE3/SSE2 could be a bit of a win.

  - Build with sse3/sse2 in separate modules.

  - Separate threaded/nonthreaded libraries.

  X Make rand_bytes() better handle the case where, after alignment, n is
    less than output_len?

  o Remove needless stirring for large rand_bytes() calls.

  o On stir, kill buffer up to pos?

  - Handle fork even better. Ideas:
    - mutex/state in a shared mmap?
    . pthread_atfork?
      (Hm, it appears that sensible libcs make getpid() pretty fast, so this
       isn't a win the way I did it at first.)
    - Ignore when we have a state object??

  - Handle thread-safety even better
    - ability to disable locking.
    - Per-pthread?
    - pthread_spin?
    - When about to generate a ton of stuff, increment the counter *then*
      drop the lock!

  - Do something about L1 cache pressure.

  X Use AESNI instead of chacha when it's available?
    o Port implementation (see branch 'aesni')
    o Benchmark implementation.
      (NOT FASTER THAN CHACHA.)
    X Test implementation
    X Use it when appropriate.

  o Windows port
    o Windows threads
    o No need for fork detection.
    - Good build process
    - Actually test on windows

  . Other entropy sources besides /dev/urandom
    - User-specified /dev/*random
    - Syscall/ioctl
    - rdrand instruction.
    o That windows thing.
    - User promises to seed (dangerous)

  - Drop endianness conversion; not needed for PRNG usage

  - Port to MSVC

  - Test on altivec, fix whatever I broke there.

  o Drop support for 64-bit counters: 256GB is enough for anyone.

  - avoid redundant initialization checks.


