/* Libottery by Nick Mathewson.

   This software has been dedicated to the public domain under the CC0
   public domain dedication.

   To the extent possible under law, the person who associated CC0 with
   libottery has waived all copyright and related or neighboring rights
   to libottery.

   You should have received a copy of the CC0 legalcode along with this
   work in doc/cc0.txt.  If not, see
      <http://creativecommons.org/publicdomain/zero/1.0/>.
*/
#ifndef OTTERY_INTERNAL_H_HEADER_INCLUDED_
#define OTTERY_INTERNAL_H_HEADER_INCLUDED_
#include <stdint.h>
#include <sys/types.h>
#include "ottery-config.h"

#ifndef OTTERY_NO_LOCKS
#if defined(__APPLE__) && !defined(OTTERY_NO_SPINLOCKS)
#define OTTERY_OSATOMIC
#include <libkern/OSAtomic.h>
#elif defined(_WIN32)
#define OTTERY_CRITICAL_SECTION
#include <windows.h>
#else
#define OTTERY_PTHREADS
#include <pthread.h>
#endif
#endif /* OTTERY_NO_LOCKS */

/** Largest possible state_bytes value. */
#define MAX_STATE_BYTES 64
/** Largest possible state_len value. */
#define MAX_STATE_LEN 256
/** Largest possible output_len value. */
#define MAX_OUTPUT_LEN 1024

/**
 * Interface to the operating system's strong RNG.  If this were fast,
 * we'd just use it for everything, and forget about having a userspace
 * PRNG.  Unfortunately, it typically isn't.
 *
 * @param fname The filename to use as /dev/urandom. Ignored if this
 *    is not a unix-like operating system. If this is NULL, we use
 *    the default value.
 * @param bytes A buffer to receive random bytes.
 * @param n The number of bytes to write
 * @return 0 on success, or an error code on failure. On failure, it is not
 *   safe to treat the contents of the buffer as random at all.
 */
int ottery_os_randbytes_(const char *fname, uint8_t *bytes, size_t n);

#if ! defined(OTTERY_NO_VECS)          \
       && (defined(__ARM_NEON__) ||    \
           defined(__ALTIVEC__)  ||    \
           defined(__SSE2__))
#define OTTERY_HAVE_SIMD_IMPL
#endif

/**
 * Information on a single pseudorandom function that we can use to generate
 * a bytestream which (we hope) an observer can't distinguish from random
 * bytes.
 *
 * Broadly speaking, every ottery_prf has an underlying function from an
 * (state_bytes)-byte state and a 4 byte counter to an output_len-byte
 * output block.
 **/
struct ottery_prf {
  /** The name of this algorithm. */
  const char *name;
  /** The name of the implementation of this algorithm*/
  const char *impl;
  /** The length of the object that's used to hold the state (keys, nonces,
   * subkeys as needed, etc) for this PRF. This can be longer than
   * state_bytes because of key expansion or structure padding.  It must be
   * no greater than MAX_STATE_LEN. */
  unsigned state_len;
  /** The number of bytes used to generate a state object. It must be no
   * greater than MAX_STATE_BYTES.  It must be no grater than output_len. */
  unsigned state_bytes;
  /** The number of bytes generated by a single call to the generate
   * function. It must be no larger than MAX_OUTPUT_LEN.
   */
  unsigned output_len;
  /** Pointer to a function to to intialize a state structure for the PRF.
   *
   * @param state An object of size at least (state_len) that will
   *     hold the state and any derived values.  It must be aligned to
   *     a 16-byte boundary.
   * @param bytes An array of (state_bytes) random bytes.
   */
  void (*setup)(void *state, const uint8_t *bytes);
  /** Pointer to a function that calculates the PRF.
   *
   * @param state A state object previously initialized by the setup
   *     function.
   * @param output An array of (output_len) bytes in which to store the
   *     result of the function
   * @param idx A counter value for the function.
   */
  void (*generate)(void *state, uint8_t *output, uint32_t idx);
};

struct ottery_config {
  /** The PRF that we should use.  If NULL, we use the default. */
  const struct ottery_prf *impl;

  /** The filename for urandom to use. If NULL, we use the default. */
  const char *urandom_fname;
};

struct __attribute__((aligned(16))) ottery_state {
  /**
   * Holds up to prf.output_len bytes that have been generated by the
   * pseudorandom function. */
  __attribute__ ((aligned (16))) uint8_t buffer[MAX_OUTPUT_LEN];
  /**
   * Holds the state information (typically nonces and keys) used by the
   * pseudorandom function. */

  __attribute__ ((aligned (16))) uint8_t state[MAX_STATE_LEN];
  /**
   * Parameters and function pointers for the cryptographic pseudorandom
   * function that we're using. */
  struct ottery_prf prf;
  /**
   * Index of the *next* block counter to use when generating random bytes
   * with prf.  When this equals or exceeds prf.stir_after, we should stir
   * the PRNG. */
  uint32_t block_counter;
  /**
   * Magic number; used to tell whether this state is initialized.
   */
  uint32_t magic;
  /**
   * Index of the next byte in (buffer) to yield to the user.
   *
   * Invariant: this is less than prf.output_len. */
  uint16_t pos;
  /**
   * The pid of the process in which this PRF was most recently seeded
   * from the OS. We use this to avoid use-after-fork problems; see
   * ottery_st_rand_lock_and_check(). */
  pid_t pid;
  /**
   * The filename for urandom to use. If NULL, we use the default.
   */
  const char *urandom_fname;
  /**
   * @brief Locks for this structure.
   *
   * This lock will not necessarily be recursive.  It's probably a
   * spinlock.
   *
   * @{
   */
#if defined(OTTERY_OSATOMIC)
  OSSpinLock mutex;
#elif defined(OTTERY_CRITICAL_SECTION)
  CRITICAL_SECTION mutex;
#elif defined(OTTERY_PTHREADS)
  pthread_mutex_t mutex;
#endif
  /**@}*/
};

struct ottery_config;
/**
 * For testing: manually supply a PRF.
 */
void ottery_config_set_manual_prf_(struct ottery_config *cfg,
                                   const struct ottery_prf *prf);

/**
 * For testing: override the use of /dev/urandom for initial
 * RNG seeding.  The fname pointe must remain value for the lifetime
 * of the ottery state.  Has no effect when /dev/urandom is not used.
 */
void ottery_config_set_urandom_device_(struct ottery_config *cfg,
                                       const char *fname);

/**
 * @brief pure-C portable ChaCha implementations.
 *
 * @{
 */
extern const struct ottery_prf ottery_prf_chacha8_merged_;
extern const struct ottery_prf ottery_prf_chacha12_merged_;
extern const struct ottery_prf ottery_prf_chacha20_merged_;
/**@}*/

#ifdef OTTERY_HAVE_SIMD_IMPL
/**
 * @brief SIMD-basd ChaCha implementations.
 *
 * These are much, much faster.
 *
 * @{ */
extern const struct ottery_prf ottery_prf_chacha8_krovetz_;
extern const struct ottery_prf ottery_prf_chacha12_krovetz_;
extern const struct ottery_prf ottery_prf_chacha20_krovetz_;
/** @} */
/** @brief Default ChaCha implementations.
 * @{ */
#define ottery_prf_chacha8_ ottery_prf_chacha8_krovetz_
#define ottery_prf_chacha12_ ottery_prf_chacha12_krovetz_
#define ottery_prf_chacha20_ ottery_prf_chacha20_krovetz_
/** @} */
#else
#define ottery_prf_chacha8_ ottery_prf_chacha8_merged_
#define ottery_prf_chacha12_ ottery_prf_chacha12_merged_
#define ottery_prf_chacha20_ ottery_prf_chacha20_merged_
#endif

#endif
